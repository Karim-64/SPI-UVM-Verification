module spi_slave_ref #(
    parameter IDLE      = 3'b000,
    parameter WRITE     = 3'b001,
    parameter CHK_CMD   = 3'b010,
    parameter READ_ADD  = 3'b011,
    parameter READ_DATA = 3'b100
) (
    input            MOSI,      // data sent from the master to the slave
    input            SS_n,      // signal by the master to enable the slave
    input            clk,
    input            rst_n,
    input      [7:0] tx_data,   // for data coming from the RAM
    input            tx_valid,  // enable to store the data coming from the RAM
    output reg       MISO,      // data sent from the slave to the master
    output reg [9:0] rx_data,   // for data to be sent to the RAM
    output reg       rx_valid   // enable for the RAM to store the data on rx_data
);

    (* fsm_encoding = "gray" *)
    reg [2:0] cs, ns;   // current state and next state
    reg [5:0] counter;  // counter for serial to parallel data conversion
    reg       rd_addr;  // a signal to know if the address is received or not
    // reg [7:0] data_in;  // to store the data coming from RAM
    reg tx_valid_flag;

    // next state logic
    always @(*) begin
        case (cs)
            IDLE:    ns = (SS_n) ? IDLE : CHK_CMD;
            CHK_CMD: begin
                if (~SS_n)
                  if (MOSI) ns = (rd_addr) ? READ_DATA : READ_ADD;
                  else ns = WRITE;
                else ns = IDLE;
            end
            WRITE:   ns = (SS_n == 1) ? IDLE : WRITE;
            READ_ADD: begin
                if (SS_n == 1) ns = IDLE;
                else ns = READ_ADD;
            end
            READ_DATA: begin
                if ( SS_n == 1) ns = IDLE;
                else ns = READ_DATA;
            end
            default: ns = IDLE;
        endcase
    end

    // current state memory and slave data handling
    always @(posedge clk) begin
        if (~rst_n) begin
            cs      <= IDLE;
            counter <= 3'b0;
            MISO    <= 0;
            rx_data <= 10'b0;
            rd_addr <= 0;
            rx_valid <= 0;

        end 
        else begin
            cs <= ns;
            if (cs == IDLE) begin
                counter <= 0;
                rx_valid <= 0;
            end
            // reciving data from the master 
            if (cs == WRITE || cs == READ_ADD) begin
                rx_valid <= (counter == 10)? 1 : 0;   
                if (counter != 10) begin
                    rx_data[9-counter] <= MOSI;  //converting serial data input
                end 
                if (cs == READ_ADD && counter==10)
                    rd_addr <= 1;  // pull up rd_addr to notify the spi that the address is transfered
                counter <= counter + 1;
            end 
            else if (cs == READ_DATA) begin
                // raising the rx_valid after 10 cycles
                rx_valid <= (counter == 10)? 1 : 0;   
                counter <= counter + 1;

                // storing data came from the master
                if (counter < 10) begin  // here we need the first two bits only and the others are dummy
                    rx_data[9-counter] <= MOSI;  //serial data input
                end 

                // at counter == 11 
                // tx_valid will be high and will send the data by the MISO
                if (tx_valid || tx_valid_flag) begin
                    tx_valid_flag <= 1;
                    if (counter > 10 && counter < 19 ) begin
                        MISO <= tx_data[19-counter];
                        if(counter == 18) begin
                            rd_addr <= 0;
                            tx_valid_flag <= 0;
                        end
                    end
                end 

                // // at counter == 12 
                // // we should begin sending the data through the MISO
                // if (counter > 11 && counter < 20 ) begin
                //     MISO <= data_in[19-counter];
                //     if(counter == 19)
                //         rd_addr <= 0;
                // end
            end
        end
    end
endmodule